package zion

import zion.*;
import robocode.*;
import robocode.ScannedRobotEvent;


// Se debe incluir SIEMPRE la definici√≥n de esta consulta, la usa el robot para recuperar las acciones
query "query"
  accion: Accion()
end


// 
// REGLAS
//


// Hecho para almacenar informacion de la victima seleccionada (si existe)
declare Victima
   nombre: String
   x: double
   y: double
   distancia: double
end


// Regla de conveniencia: elimina acciones del mismo tipo con menor prioridad
// Si no se hiciera el robot ejecutar√≠a la √∫ltima acci√≥n insertada sin atender a su pioridad
rule "depurar acciones del mismo tipo"
dialect "mvel"
when
	$accion1: Accion($tipo: tipo, $prioridad1: prioridad)
	$accion2: Accion(tipo==$tipo, $prioridad2: prioridad)
	eval ($prioridad1 > $prioridad2)
then
    retract($accion2);     // Elimina la accion menos prioritaria 
    System.out.println("regla 1");
end

// Cuando no hay robots detectados forzar un giro completo del radar
rule "sin robots a la vista -> giro completo del radar"
when
	not (exists ScannedRobotEvent())
then
	insert (new Accion(Accion.GIRAR_RADAR_DER, 360, 1));
	System.out.println("regla 2");
end

// // No necesaria ¬ø?
//rule "sin victima fijada -> giro completo del radar"
//when
//      not (exists Victima())
//then
//      insert (new Accion(Accion.GIRAR_RADAR_DER, 360, 1));
//      System.out.println("regla 2-bis");
//end

// Cuando esta parado y no hay victima girar radar 360 y moverse al azar
rule "parado sin victima -> moverse al azar (girar+avanzar)"
when
  EstadoRobot( distanceRemaining == 0 )
  not (exists Victima())
  $batalla: EstadoBatalla()
then
  insert(new Accion(Accion.GIRAR_RADAR_DER, 360, 1));
  insert(new Accion(Accion.GIRAR_TANQUE_DER, (360*Math.random() - 180), 1));
  insert(new Accion(Accion.GIRAR_CANON_DER, (360*Math.random() - 180), 1));
  double avance = Math.min($batalla.getAnchoCampo(), $batalla.getAltoCampo())*Math.random();
  insert(new Accion(Accion.AVANZAR, avance, 1));
  System.out.println("regla 3");
end


// Victima detectada por radar, actualizar su localizacion e ir hacia ella apunt√°ndola con ca√±on y radar
rule "victima detectada -> actualizar datos e ir hacia ella"
   when
      $datosVictima: Victima ($nombreVictima: nombre)
      $status : EstadoRobot()
      $victimaEscaneada: ScannedRobotEvent(name == $nombreVictima)
   then
      double anguloAbsoluto = Auxiliar.anguloAbsoluto($status.getHeading(), $victimaEscaneada.getBearing());
      $datosVictima.setX(Auxiliar.calcularX($status.getX(), anguloAbsoluto, $victimaEscaneada.getDistance()));                                            
      $datosVictima.setY(Auxiliar.calcularX($status.getY(), anguloAbsoluto, $victimaEscaneada.getDistance()));
      $datosVictima.setDistancia($victimaEscaneada.getDistance());
      // ########### AQUI!!
      //insert(new Accion(Accion.BROADCAST, new EnemySpotted($datosVictima.getNombre(), $victimaEscaneada.getBearing(), $victimaEscaneada.getDistance()), 1));
      
      Point p = EnemySpotted.calcularPonto($status.getX(), $status.getY(), $status.getHeading(), $victimaEscaneada.getBearing(), $victimaEscaneada.getDistance());
      insert(new Accion(Accion.BROADCAST, new EnemySpotted($datosVictima.getNombre(), p.getX(), p.getY()), 1));
      
      insert(new Accion(Accion.GIRAR_TANQUE_DER, $victimaEscaneada.getBearing(), 1));
      double anguloRelativoCanon = Auxiliar.anguloRelativo($status.getHeading(), $status.getGunHeading()); // Descontar el desplazam. actual del canon 
      insert(new Accion(Accion.GIRAR_CANON_DER, ($victimaEscaneada.getBearing() - anguloRelativoCanon), 1));
      double anguloRelativoRadar =  Auxiliar.anguloRelativo($status.getHeading(), $status.getRadarHeading()); // Descontar el desplazam. actual del radar  
      insert(new Accion(Accion.GIRAR_RADAR_DER, ($victimaEscaneada.getBearing() - anguloRelativoRadar), 1));
      insert(new Accion(Accion.AVANZAR, ($victimaEscaneada.getDistance()-120), 1));
end



// Victima detectada por radar, si est√° en el punto de mira (anguloRelativoCa√±√≥n == anguloRelativoVictima) con un margen de 2 grados, disparar con el maximo disponible
//  (se activar√° a lavez que la regla anterior)
rule "Alvo na mira"
   when
      $status : EstadoRobot()
      $datosVictima : Victima ($nombreVictima: nombre)
      // Victima detectada y ca√±on apunta en su angulo (con un margen de 2 grados)
      $scanned : ScannedRobotEvent(name == $nombreVictima, $anguloRelativoVictima: bearing)                       
      eval (Math.abs($anguloRelativoVictima - Auxiliar.anguloRelativo($status.getHeading(), $status.getGunHeading())) <= 2)   
   then
   // ########### AQUI!!!
   	  //insert(new Accion(Accion.BROADCAST, new EnemySpotted($datosVictima.getNombre(), $scanned.getBearing(), $scanned.getDistance()), 1));
   	  
   	  Point p = EnemySpotted.calcularPonto($status.getX(), $status.getY(), $status.getHeading(), $scanned.getBearing(), $scanned.getDistance());
      insert(new Accion(Accion.BROADCAST, new EnemySpotted($datosVictima.getNombre(), p.getX(), p.getY()), 1));
   	  
      insert(new Accion(Accion.DISPARAR, Math.min(Rules.MAX_BULLET_POWER, 0.10*$status.getEnergy()), 1));
      System.out.println("Target "+$nombreVictima+" aimed!");
end



// Cuando no hay una v√≠ctima se√±alada y se escanea un robot,  anotarlo como v√≠ctima e ir hacia √©l apuntando radar y ca√±√≥n
rule "Primeiro inimigo encontrado pelo radar"
when
	not (exists Victima())
	$victimaEscaneada: ScannedRobotEvent()
	$status: EstadoRobot()
then
    Victima victima = new Victima();
      double anguloAbsoluto = Auxiliar.anguloAbsoluto($status.getHeading(), $victimaEscaneada.getBearing());
      victima.setNombre($victimaEscaneada.getName());
      victima.setX(Auxiliar.calcularX($status.getX(), anguloAbsoluto, $victimaEscaneada.getDistance()));                                            
      victima.setY(Auxiliar.calcularX($status.getY(), anguloAbsoluto, $victimaEscaneada.getDistance()));
      victima.setDistancia($victimaEscaneada.getDistance());
      insert(victima);
      // ########### AQUI!!!
//      insert(new Accion(Accion.BROADCAST, new EnemySpotted(victima.getNombre(), $victimaEscaneada.getBearing(), $victimaEscaneada.getDistance()), 1));
      
      Point p = EnemySpotted.calcularPonto($status.getX(), $status.getY(), $status.getHeading(), $victimaEscaneada.getBearing(), $victimaEscaneada.getDistance());
      insert(new Accion(Accion.BROADCAST, new EnemySpotted(victima.getNombre(), p.getX(), p.getY()), 1));
      
      insert(new Accion(Accion.GIRAR_TANQUE_DER, $victimaEscaneada.getBearing(), 1));
      double anguloRelativoCanon = Auxiliar.anguloRelativo($status.getHeading(), $status.getGunHeading()); // Descontar el desplazam. actual del canon 
      insert(new Accion(Accion.GIRAR_CANON_DER, ($victimaEscaneada.getBearing() - anguloRelativoCanon), 1));
      double anguloRelativoRadar =  Auxiliar.anguloRelativo($status.getHeading(), $status.getRadarHeading()); // Descontar el desplazam. actual del radar  
      insert(new Accion(Accion.GIRAR_RADAR_DER, ($victimaEscaneada.getBearing() - anguloRelativoRadar), 1));
      insert(new Accion(Accion.AVANZAR, ($victimaEscaneada.getDistance()-120), 1));    
      System.out.println("regla 6"); 
end

rule "Quando não existir vítima e uma mensagem de detecção de inimigo -> vítima é esse inimigo"
when
	not (exists Victima())
	$enemyMessage: EnemySpotted($enemyName: enemyName != null)
then
    Victima victima = new Victima();
    victima.setNombre($enemyName);
    insert(victima);
    System.out.println($enemyName + "é o alvo");
end

// Eliminar el hecho Victima() actual una vez liquidada
rule "muerte de la victima"
when
   $victima: Victima ($nombreVictima: nombre)
   RobotDeathEvent( name == $nombreVictima )
then 
   retract($victima);
   System.out.println("Morreu, pai!!!");
end


// Al chocar con un muro, salir "rebotado" en el angulo opuesto
//   (tiene prioridad 5 para evitar que otras acciones "normales" nos hagan quedar estancados)  
rule "choque con muro"
when
   HitWallEvent($anguloRelativo: bearing)
then
   insert(new Accion(Accion.GIRAR_TANQUE_DER, (- $anguloRelativo), 5));
   insert(new Accion(Accion.AVANZAR, 100, 5));
end


// Al chocar con victima, retroceder
//   (tiene prioridad 5 para evitar que otras acciones "normales" nos hagan quedar estancados)  
rule "choque con victima"
when
   HitRobotEvent($nombre: name, $anguloRelativo: bearing)
   Victima(nombre == $nombre)
then
   insert(new Accion(Accion.RETROCEDER, 100, 5));
end

// Al chocar con otro robot que no sea la v√≠ctima (o si esta no existe), salir "rebotado" en el angulo opuesto
//   (tiene prioridad 5 para evitar que otras acciones "normales" nos hagan quedar estancados)  
rule "choque con otro robot"
when
   HitRobotEvent($nombre: name, $anguloRelativo: bearing)
   (or (not (exists Victima()))
       (Victima(nombre != $nombre)))
then
   insert(new Accion(Accion.GIRAR_TANQUE_DER, (- $anguloRelativo*1.50), 5));
   insert(new Accion(Accion.AVANZAR, 100, 5));
end

