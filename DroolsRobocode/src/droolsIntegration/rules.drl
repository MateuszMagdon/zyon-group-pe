package droolsIntegration

import droolsIntegration.*;
import robocode.*;
import robocode.ScannedRobotEvent;
import util.Util;


query "actionQuery"
  action: Action()
end


// 
// REGLAS
//


// Hecho para almacenar informacion de la victima seleccionada (si existe)
declare Target
   name: String
   x: double
   y: double
   distance: double
end


// Regla de conveniencia: elimina acciones del mismo tipo con menor prioridad
// Si no se hiciera el robot ejecutaría la última acción insertada sin atender a su pioridad
rule "depurar acciones del mismo tipo"
when
	$action1: Action($type: type, $pri1: priority)
	$action2: Action(type == $type, $pri2: priority)
	eval ($pri1 > $pri2)
then
    retract($action2);     // Elimina la accion menos prioritaria 
    System.out.println("regla 1");
end

// Cuando no hay robots detectados forzar un giro completo del radar
rule "sin robots a la vista -> giro completo del radar"
when
	not (exists ScannedRobotEvent())
then
	insert (new Action(ActionType.TURN_RADAR_RIGHT, 360, 1));
	System.out.println("regla 2");
end

// Cuando esta parado y no hay victima girar radar 360 y moverse al azar
rule "parado sin victima -> moverse al azar (girar+avanzar)"
when
  RobotState( distanceRemaining == 0 )
  not (exists Target())
  $battle: BattleState()
then
  insert(new Action(ActionType.TURN_RADAR_RIGHT, 360, 1));
  insert(new Action(ActionType.TURN_RIGHT, (360*Math.random() - 180), 1));
  insert(new Action(ActionType.TURN_GUN_RIGHT, (360*Math.random() - 180), 1));
  double forward = Math.min($battle.getArenaHeight(), $battle.getArenaWidth())*Math.random();
  insert(new Action(ActionType.AHEAD, forward, 1));
  System.out.println("regla 3");
end


// Victima detectada por radar, actualizar su localizacion e ir hacia ella apuntándola con cañon y radar
rule "victima detectada -> actualizar datos e ir hacia ella"
   when
      $target: Target ($targetName: name)
      $status : RobotState()
      $scannedTarget: ScannedRobotEvent(name == $targetName)
   then
      	double x = $status.getHeading() + $scannedTarget.getBearing();
      	double enemyX = $status.getX() + $scannedTarget.getDistance() * Math.sin(Math.toRadians(enemyBearing));
		double enemyY = $status.getY() + $scannedTarget.getDistance() * Math.cos(Math.toRadians(enemyBearing));
  	  
	  	$target.setX(enemyX);                                            
      	$target.setY(enemyY);
      	$target.setDistance($scannedTarget.getDistance());
      
      	insert(new Action(ActionType.TURN_RIGHT, $scannedTarget.getBearing(), 1));
      	double relativeGunAngle = Util.relativeAngle($status.getHeading(), $status.getGunHeading()); // Descontar el desplazam. actual del canon 
     	insert(new Action(ActionType.TURN_GUN_RIGHT, ($scannedTarget.getBearing() - relativeGunAngle), 1));
      	double relativeRadarAngle =  Util.relativeAngle($status.getHeading(), $status.getRadarHeading()); // Descontar el desplazam. actual del radar  
      	insert(new Action(ActionType.TURN_RADAR_RIGHT, ($scannedTarget.getBearing() - relativeRadarAngle), 1));
      	insert(new Action(ActionType.AHEAD, ($scannedTarget.getDistance()-100), 1));
      	System.out.println("regla 4");
end



// Victima detectada por radar, si está en el punto de mira (anguloRelativoCañón == anguloRelativoVictima) con un margen de 2 grados, disparar con el maximo disponible
//  (se activará a lavez que la regla anterior)
rule "victima en punto de mira -> disparar"
   when
      $status : RobotState()
      Target ($targetName: name)
      // Victima detectada y cañon apunta en su angulo (con un margen de 2 grados)
      ScannedRobotEvent(name == $targetName, $relativeTargetAngle: x)                       
      eval (Math.abs($relativeTargetAngle - Util.relativeAngle($status.getHeading(), $status.getGunHeading())) <= 2)   
   then
      insert(new Action(ActionType.FIRE, Math.min(Rules.MAX_BULLET_POWER, 0.10*$status.getEnergy()), 1));
      System.out.println("Victima "+$targetName+" a tiro => disparar");
end



// Cuando no hay una víctima señalada y se escanea un robot,  anotarlo como víctima e ir hacia él apuntando radar y cañón
rule "sin victima -> tomar la primera que aparezca"
when
	not (exists Target())
	$scannedTarget: ScannedRobotEvent()
	$status: RobotState()
then
      	Target target = new Target();
      	target.setName($scannedTarget.getName());
      	double x = $status.getHeading() + $scannedTarget.getBearing();
      	double enemyX = $status.getX() + $scannedTarget.getDistance() * Math.sin(Math.toRadians(enemyBearing));
		double enemyY = $status.getY() + $scannedTarget.getDistance() * Math.cos(Math.toRadians(enemyBearing));
  	  
	  	target.setX(enemyX);                                            
      	target.setY(enemyY);
      	target.setDistance($scannedTarget.getDistance());
      
      	insert(target);
      
      	insert(new Action(ActionType.TURN_RIGHT, $scannedTarget.getBearing(), 1));
      	double relativeGunAngle = Util.relativeAngle($status.getHeading(), $status.getGunHeading()); // Descontar el desplazam. actual del canon 
      	insert(new Action(ActionType.TURN_GUN_RIGHT, ($scannedTarget.getBearing() - relativeGunAngle), 1));
      	double relativeRadarAngle =  Util.relativeAngle($status.getHeading(), $status.getRadarHeading()); // Descontar el desplazam. actual del radar  
      	insert(new Action(ActionType.TURN_RADAR_RIGHT, ($scannedTarget.getBearing() - relativeRadarAngle), 1));
      	insert(new Action(ActionType.AHEAD, ($scannedTarget.getDistance()-100), 1));    
      	System.out.println("regla 6"); 
end

// Eliminar el hecho Victima() actual una vez liquidada
rule "muerte de la victima"
when
   $target: Target ($name: name)
   RobotDeathEvent( name == $name )
then 
   retract($target);
   System.out.println("Uno menos");
end


// Al chocar con un muro, salir "rebotado" en el angulo opuesto
//   (tiene prioridad 5 para evitar que otras acciones "normales" nos hagan quedar estancados)  
rule "choque con muro"
when
   HitWallEvent($relativeAngle: x)
then
   insert(new Action(ActionType.TURN_RIGHT, (- $relativeAngle), 5));
   insert(new Action(ActionType.AHEAD, 100, 5));
end


// Al chocar con victima, retroceder
//   (tiene prioridad 5 para evitar que otras acciones "normales" nos hagan quedar estancados)  
rule "choque con victima"
when
   HitRobotEvent($name: name, $relativeAngle: x)
   Target(name == $name)
then
   insert(new Action(ActionType.BACK, 100, 5));
end

// Al chocar con otro robot que no sea la víctima (o si esta no existe), salir "rebotado" en el angulo opuesto
//   (tiene prioridad 5 para evitar que otras acciones "normales" nos hagan quedar estancados)  
rule "choque con otro robot"
when
   HitRobotEvent($name: name, $relativeAngle: x)
   (or (not (exists Target())) (Target(name != $name)) )
then
   insert(new Action(ActionType.TURN_RIGHT, (- $relativeAngle*1.50), 5));
   insert(new Action(ActionType.AHEAD, 100, 5));
end

